var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement } from 'lit';
import { customElement, property, query, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { chevronDownIcon } from '../includes/vscode-select/template-elements.js';
import { VscodeSelectBase } from '../includes/vscode-select/vscode-select-base.js';
import styles from './vscode-single-select.styles.js';
import { highlightRanges } from '../includes/vscode-select/helpers.js';
/**
 * Allows to select an item from multiple options.
 *
 * When participating in a form, it supports the `:invalid` pseudo class. Otherwise the error styles
 * can be applied through the `invalid` property.
 *
 * ## Types
 *
 * ```typescript
 *interface Option {
 *  label: string;
 *  value: string;
 *  description: string;
 *  selected: boolean;
 *  disabled: boolean;
 *}
 * ```
 * @prop {boolean} invalid
 * @attr {boolean} invalid
 * @attr name - Name which is used as a variable name in the data of the form-container.
 * @cssprop [--dropdown-z-index=2]
 * @cssprop --vscode-badge-background
 * @cssprop --vscode-badge-foreground
 * @cssprop --vscode-settings-dropdownBorder
 * @cssprop --vscode-settings-checkboxBackground
 * @cssprop --vscode-settings-dropdownBackground
 * @cssprop --vscode-settings-dropdownListBorder
 * @cssprop --vscode-focusBorder
 * @cssprop --vscode-foreground
 * @cssprop --vscode-font-family
 * @cssprop --vscode-font-size
 * @cssprop --vscode-font-weight
 * @cssprop --vscode-list-activeSelectionBackground
 * @cssprop --vscode-list-activeSelectionForeground
 * @cssprop --vscode-list-focusOutline
 * @cssprop --vscode-list-highlightForeground
 * @cssprop --vscode-list-focusHighlightForeground
 * @cssprop --vscode-list-hoverBackground
 * @cssprop --vscode-list-hoverForeground
 * @cssprop --vscode-list-hoverBackground
 * @cssprop --vscode-settings-textInputBackground
 */
let VscodeSingleSelect = class VscodeSingleSelect extends VscodeSelectBase {
    set selectedIndex(val) {
        this._selectedIndex = val;
        this._value = this._options[this._selectedIndex]
            ? this._options[this._selectedIndex].value
            : '';
        this._labelText = this._options[this._selectedIndex]
            ? this._options[this._selectedIndex].label
            : '';
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set value(val) {
        if (this._options[this._selectedIndex]) {
            this._options[this._selectedIndex].selected = false;
        }
        this._selectedIndex = this._options.findIndex((op) => op.value === val);
        if (this._selectedIndex > -1) {
            this._options[this._selectedIndex].selected = true;
            this._labelText = this._options[this._selectedIndex].label;
            this._value = val;
            this._requestedValueToSetLater = '';
        }
        else {
            this._labelText = '';
            this._value = '';
            this._requestedValueToSetLater = val;
        }
    }
    get value() {
        if (this._options[this._selectedIndex]) {
            return this._options[this._selectedIndex]?.value ?? '';
        }
        return '';
    }
    get validity() {
        return this._internals.validity;
    }
    get validationMessage() {
        return this._internals.validationMessage;
    }
    get willValidate() {
        return this._internals.willValidate;
    }
    checkValidity() {
        return this._internals.checkValidity();
    }
    reportValidity() {
        return this._internals.reportValidity();
    }
    updateInputValue() {
        if (!this.combobox) {
            return;
        }
        const input = this.renderRoot.querySelector('.combobox-input');
        if (input) {
            input.value = this._options[this._selectedIndex]
                ? this._options[this._selectedIndex].label
                : '';
        }
    }
    constructor() {
        super();
        this.defaultValue = '';
        /** @internal */
        this.role = 'listbox';
        this.name = undefined;
        this.required = false;
        this._labelText = '';
        this._requestedValueToSetLater = '';
        /** @internal */
        this._multiple = false;
        this._internals = this.attachInternals();
    }
    connectedCallback() {
        super.connectedCallback();
        this.updateComplete.then(() => {
            this._manageRequired();
        });
    }
    /** @internal */
    formResetCallback() {
        this.value = this.defaultValue;
    }
    /** @internal */
    formStateRestoreCallback(state, _mode) {
        this.updateComplete.then(() => {
            this.value = state;
        });
    }
    /** @internal */
    get type() {
        return 'select-one';
    }
    get form() {
        return this._internals.form;
    }
    _onSlotChange() {
        super._onSlotChange();
        if (this._requestedValueToSetLater) {
            // the value is set before the available options are appended
            const foundIndex = this._options.findIndex((op) => op.value === this._requestedValueToSetLater);
            if (foundIndex > 0) {
                this._selectedIndex = foundIndex;
                this._requestedValueToSetLater = '';
            }
        }
        if (this._selectedIndex > -1) {
            this._labelText = this._options[this._selectedIndex]?.label ?? '';
        }
        if (this._selectedIndex > -1 && this._options.length > 0) {
            this._internals.setFormValue(this._options[this._selectedIndex].value);
        }
        else {
            this._internals.setFormValue(null);
        }
    }
    _onArrowUpKeyDown() {
        super._onArrowUpKeyDown();
        if (this._showDropdown || this._selectedIndex <= 0) {
            return;
        }
        this._filterPattern = '';
        this._selectedIndex -= 1;
        this._activeIndex = this._selectedIndex;
        this._labelText = this._options[this._selectedIndex].label;
        this._value = this._options[this._selectedIndex].value;
        this._internals.setFormValue(this._value);
        this._manageRequired();
        this._dispatchChangeEvent();
    }
    _onArrowDownKeyDown() {
        super._onArrowDownKeyDown();
        if (this._showDropdown || this._selectedIndex >= this._options.length - 1) {
            return;
        }
        this._filterPattern = '';
        this._selectedIndex += 1;
        this._activeIndex = this._selectedIndex;
        this._labelText = this._options[this._selectedIndex].label;
        this._value = this._options[this._selectedIndex].value;
        this._internals.setFormValue(this._value);
        this._manageRequired();
        this._dispatchChangeEvent();
    }
    _onEnterKeyDown() {
        super._onEnterKeyDown();
        if (this._selectedIndex > -1) {
            this._labelText = this._options[this._selectedIndex].label;
        }
        this.updateInputValue();
        this._internals.setFormValue(this._value);
        this._manageRequired();
    }
    _onOptionClick(ev) {
        const composedPath = ev.composedPath();
        const optEl = composedPath.find((et) => et?.matches('li.option'));
        if (!optEl || optEl.matches('.disabled')) {
            return;
        }
        this._selectedIndex = Number(optEl.dataset.index);
        this._value = this._options[this._selectedIndex].value;
        if (this._selectedIndex > -1) {
            this._labelText = this._options[this._selectedIndex].label;
        }
        this._toggleDropdown(false);
        this._internals.setFormValue(this._value);
        this._manageRequired();
        this._dispatchChangeEvent();
    }
    _manageRequired() {
        const { value } = this;
        if (value === '' && this.required) {
            this._internals.setValidity({
                valueMissing: true,
            }, 'Please select an item in the list.', this._face);
        }
        else {
            this._internals.setValidity({});
        }
    }
    _renderSelectFace() {
        return html `
      <div
        class="select-face face"
        @click="${this._onFaceClick}"
        tabindex="${this.tabIndex > -1 ? 0 : -1}"
      >
        <span class="text">${this._labelText}</span> ${chevronDownIcon}
      </div>
    `;
    }
    _renderComboboxFace() {
        const inputVal = this._selectedIndex > -1 ? this._options[this._selectedIndex].label : '';
        return html `
      <div class="combobox-face face">
        <input
          class="combobox-input"
          spellcheck="false"
          type="text"
          .value="${inputVal}"
          @focus="${this._onComboboxInputFocus}"
          @input="${this._onComboboxInputInput}"
          @click=${this._onComboboxInputClick}
        />
        <button
          class="combobox-button"
          type="button"
          @click="${this._onComboboxButtonClick}"
          @keydown="${this._onComboboxButtonKeyDown}"
        >
          ${chevronDownIcon}
        </button>
      </div>
    `;
    }
    _renderOptions() {
        const list = this.combobox ? this._filteredOptions : this._options;
        const options = list.map((op, index) => {
            const classes = classMap({
                option: true,
                active: index === this._activeIndex && !op.disabled,
                disabled: op.disabled,
            });
            return html `
        <li
          class="${classes}"
          data-index="${op.index}"
          data-filtered-index="${index}"
        >
          ${(op.ranges?.length ?? 0 > 0)
                ? highlightRanges(op.label, op.ranges ?? [])
                : op.label}
        </li>
      `;
        });
        return html `
      <ul
        class="options"
        @mouseover="${this._onOptionMouseOver}"
        @click="${this._onOptionClick}"
      >
        ${options}
      </ul>
    `;
    }
};
VscodeSingleSelect.styles = styles;
/** @internal */
VscodeSingleSelect.shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
};
/** @internal */
VscodeSingleSelect.formAssociated = true;
__decorate([
    property({ attribute: 'default-value' })
], VscodeSingleSelect.prototype, "defaultValue", void 0);
__decorate([
    property({ type: String, attribute: true, reflect: true })
], VscodeSingleSelect.prototype, "role", void 0);
__decorate([
    property({ reflect: true })
], VscodeSingleSelect.prototype, "name", void 0);
__decorate([
    property({ type: Number, attribute: 'selected-index' })
], VscodeSingleSelect.prototype, "selectedIndex", null);
__decorate([
    property({ type: String })
], VscodeSingleSelect.prototype, "value", null);
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeSingleSelect.prototype, "required", void 0);
__decorate([
    state()
], VscodeSingleSelect.prototype, "_labelText", void 0);
__decorate([
    query('.face')
], VscodeSingleSelect.prototype, "_face", void 0);
VscodeSingleSelect = __decorate([
    customElement('vscode-single-select')
], VscodeSingleSelect);
export { VscodeSingleSelect };
//# sourceMappingURL=vscode-single-select.js.map