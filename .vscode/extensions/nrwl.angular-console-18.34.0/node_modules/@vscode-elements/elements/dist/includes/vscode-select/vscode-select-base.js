var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, nothing } from 'lit';
import { property, query, queryAssignedElements, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import '../../vscode-button/index.js';
import '../../vscode-option/index.js';
import { filterOptionsByPattern } from './helpers.js';
import { VscElement } from '../VscElement.js';
const VISIBLE_OPTS = 10;
const OPT_HEIGHT = 22;
const LIST_HEIGHT = VISIBLE_OPTS + OPT_HEIGHT + 2;
/**
 * @cssprop --dropdown-z-index - workaround for dropdown z-index issues
 */
export class VscodeSelectBase extends VscElement {
    constructor() {
        super(...arguments);
        /** @internal */
        this.ariaExpanded = 'false';
        this.combobox = false;
        /**
         * Sets the invalid state manually.
         */
        this.invalid = false;
        this.focused = false;
        /**
         * Position of the options list when visible.
         */
        this.position = 'below';
        /** @internal */
        this.tabIndex = 0;
        this._activeIndex = -1;
        this._currentDescription = '';
        this._filter = 'fuzzy';
        this._filterPattern = '';
        this._selectedIndex = -1;
        this._selectedIndexes = [];
        this._showDropdown = false;
        this._options = [];
        this._value = '';
        this._values = [];
        this._listScrollTop = 0;
        /** @internal */
        this._multiple = false;
        /**
         * @internal
         * Quick-searchable map for searching a value in the options list.
         * Keys are the options values, values are the option indexes.
         */
        this._valueOptionIndexMap = {};
        this._isHoverForbidden = false;
        this._disabled = false;
        this._originalTabIndex = undefined;
        this._onClickOutside = (event) => {
            const path = event.composedPath();
            const found = path.findIndex((et) => et === this);
            if (found === -1) {
                this._toggleDropdown(false);
                window.removeEventListener('click', this._onClickOutside);
            }
        };
        this._onMouseMove = () => {
            this._isHoverForbidden = false;
            window.removeEventListener('mousemove', this._onMouseMove);
        };
    }
    set disabled(newState) {
        this._disabled = newState;
        this.ariaDisabled = newState ? 'true' : 'false';
        if (newState === true) {
            this._originalTabIndex = this.tabIndex;
            this.tabIndex = -1;
        }
        else {
            this.tabIndex = this._originalTabIndex ?? 0;
            this._originalTabIndex = undefined;
        }
        this.requestUpdate();
    }
    get disabled() {
        return this._disabled;
    }
    /**
     * Search method in the filtered list within the combobox mode.
     *
     * - contains - The list item includes the searched pattern at any position.
     * - fuzzy - The list item contains the letters of the search pattern in the same order, but at any position.
     * - startsWith - The search pattern matches the beginning of the searched text.
     * - startsWithPerTerm - The search pattern matches the beginning of any word in the searched text.
     *
     * @default 'fuzzy'
     */
    set filter(val) {
        const validValues = [
            'contains',
            'fuzzy',
            'startsWith',
            'startsWithPerTerm',
        ];
        if (validValues.includes(val)) {
            this._filter = val;
        }
        else {
            this._filter = 'fuzzy';
            console.warn(`[VSCode Webview Elements] Invalid filter: "${val}", fallback to default. Valid values are: "contains", "fuzzy", "startsWith", "startsWithPerm".`, this);
        }
    }
    get filter() {
        return this._filter;
    }
    /**
     * @attr [options=[]]
     * @type {Option[]}
     */
    set options(opts) {
        this._options = opts.map((op, index) => ({ ...op, index }));
    }
    get options() {
        return this._options.map(({ label, value, description, selected, disabled }) => ({
            label,
            value,
            description,
            selected,
            disabled,
        }));
    }
    connectedCallback() {
        super.connectedCallback();
        this.addEventListener('keydown', this._onComponentKeyDown);
        this.addEventListener('focus', this._onComponentFocus);
        this.addEventListener('blur', this._onComponentBlur);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener('keydown', this._onComponentKeyDown);
        this.removeEventListener('focus', this._onComponentFocus);
        this.removeEventListener('blur', this._onComponentBlur);
    }
    get _filteredOptions() {
        if (!this.combobox || this._filterPattern === '') {
            return this._options;
        }
        return filterOptionsByPattern(this._options, this._filterPattern, this._filter);
    }
    get _currentOptions() {
        return this.combobox ? this._filteredOptions : this._options;
    }
    _addOptionsFromSlottedElements() {
        const options = [];
        let nextIndex = 0;
        const optionElements = this._assignedOptions ?? [];
        const optionsListStat = {
            selectedIndexes: [],
            values: [],
        };
        this._valueOptionIndexMap = {};
        optionElements.forEach((el) => {
            const { innerText, description, disabled } = el;
            const value = (el.value ?? '') ? el.value : innerText.trim();
            const selected = el.selected ?? false;
            const op = {
                label: innerText.trim(),
                value,
                description,
                selected,
                index: nextIndex,
                disabled,
            };
            nextIndex = options.push(op);
            if (selected) {
                optionsListStat.selectedIndexes.push(options.length - 1);
                optionsListStat.values.push(value);
            }
            this._valueOptionIndexMap[op.value] = op.index;
        });
        this._options = options;
        return optionsListStat;
    }
    async _toggleDropdown(visible) {
        this._showDropdown = visible;
        this.ariaExpanded = String(visible);
        if (visible && !this._multiple && !this.combobox) {
            this._activeIndex = this._selectedIndex;
            if (this._activeIndex > VISIBLE_OPTS - 1) {
                await this.updateComplete;
                this._listElement.scrollTop = Math.floor(this._activeIndex * OPT_HEIGHT);
            }
        }
        if (visible) {
            window.addEventListener('click', this._onClickOutside);
        }
        else {
            window.removeEventListener('click', this._onClickOutside);
        }
    }
    _dispatchChangeEvent() {
        if (!this._multiple) {
            /** @deprecated */
            this.dispatchEvent(new CustomEvent('vsc-change', {
                detail: {
                    selectedIndex: this._selectedIndex,
                    value: this._value,
                },
            }));
        }
        else {
            /** @deprecated */
            this.dispatchEvent(new CustomEvent('vsc-change', {
                detail: {
                    selectedIndexes: this._selectedIndexes,
                    value: this._values,
                },
            }));
        }
        this.dispatchEvent(new Event('change'));
        this.dispatchEvent(new Event('input'));
    }
    _onFaceClick() {
        this._toggleDropdown(!this._showDropdown);
        if (this._multiple) {
            this._activeIndex = 0;
        }
    }
    _toggleComboboxDropdown() {
        this._filterPattern = '';
        this._toggleDropdown(!this._showDropdown);
        if (this._multiple) {
            this._activeIndex = -1;
        }
    }
    _onComboboxButtonClick() {
        this._toggleComboboxDropdown();
    }
    _onComboboxButtonKeyDown(ev) {
        if (ev.key === 'Enter') {
            this._toggleComboboxDropdown();
        }
    }
    _onOptionMouseOver(ev) {
        if (this._isHoverForbidden) {
            return;
        }
        const el = ev.target;
        if (!el.matches('.option')) {
            return;
        }
        this._activeIndex = Number(this.combobox ? el.dataset.filteredIndex : el.dataset.index);
    }
    _onEnterKeyDown() {
        const list = this.combobox ? this._filteredOptions : this._options;
        const showDropdownNext = !this._showDropdown;
        this._toggleDropdown(showDropdownNext);
        if (!this._multiple &&
            !showDropdownNext &&
            this._selectedIndex !== this._activeIndex) {
            this._selectedIndex = list[this._activeIndex].index;
            this._value = this._options[this._selectedIndex].value;
            this._dispatchChangeEvent();
        }
        if (this.combobox) {
            if (!this._multiple && !showDropdownNext) {
                this._selectedIndex = this._filteredOptions[this._activeIndex].index;
            }
            if (!this._multiple && showDropdownNext) {
                this.updateComplete.then(() => {
                    this._scrollActiveElementToTop();
                });
            }
        }
        if (this._multiple && showDropdownNext) {
            this._activeIndex = 0;
        }
    }
    _onSpaceKeyDown() {
        if (!this._showDropdown) {
            this._toggleDropdown(true);
            return;
        }
        if (this._showDropdown && this._multiple && this._activeIndex > -1) {
            const opts = this.combobox ? this._filteredOptions : this._options;
            const { selected } = opts[this._activeIndex];
            opts[this._activeIndex].selected = !selected;
            this._selectedIndexes = [];
            opts.forEach(({ index, selected }) => {
                if (selected) {
                    this._selectedIndexes.push(index);
                }
            });
        }
    }
    _scrollActiveElementToTop() {
        this._listElement.scrollTop = Math.floor(this._activeIndex * OPT_HEIGHT);
    }
    async _adjustOptionListScrollPos(direction) {
        const numOpts = this.combobox
            ? this._filteredOptions.length
            : this._options.length;
        if (numOpts <= VISIBLE_OPTS) {
            return;
        }
        this._isHoverForbidden = true;
        window.addEventListener('mousemove', this._onMouseMove);
        if (!this._listElement) {
            await this.updateComplete;
        }
        const ulScrollTop = this._listElement.scrollTop;
        const liPosY = this._activeIndex * OPT_HEIGHT;
        if (direction === 'down') {
            if (liPosY + OPT_HEIGHT >= LIST_HEIGHT + ulScrollTop) {
                this._listElement.scrollTop =
                    (this._activeIndex - (VISIBLE_OPTS - 1)) * OPT_HEIGHT;
            }
        }
        if (direction === 'up') {
            if (liPosY <= ulScrollTop - OPT_HEIGHT) {
                this._scrollActiveElementToTop();
            }
        }
    }
    _onArrowUpKeyDown() {
        if (this._showDropdown) {
            if (this._activeIndex <= 0) {
                return;
            }
            this._activeIndex -= 1;
            this._adjustOptionListScrollPos('up');
        }
    }
    _onArrowDownKeyDown() {
        if (this._showDropdown) {
            if (this._activeIndex >= this._currentOptions.length - 1) {
                return;
            }
            this._activeIndex += 1;
            this._adjustOptionListScrollPos('down');
        }
    }
    _onComponentKeyDown(event) {
        if ([' ', 'ArrowUp', 'ArrowDown', 'Escape'].includes(event.key)) {
            event.stopPropagation();
            event.preventDefault();
        }
        if (event.key === 'Enter') {
            this._onEnterKeyDown();
        }
        if (event.key === ' ') {
            this._onSpaceKeyDown();
        }
        if (event.key === 'Escape') {
            this._toggleDropdown(false);
        }
        if (event.key === 'ArrowUp') {
            this._onArrowUpKeyDown();
        }
        if (event.key === 'ArrowDown') {
            this._onArrowDownKeyDown();
        }
    }
    _onComponentFocus() {
        this.focused = true;
    }
    _onComponentBlur() {
        this.focused = false;
    }
    _onSlotChange() {
        const stat = this._addOptionsFromSlottedElements();
        if (stat.selectedIndexes.length > 0) {
            this._selectedIndex = stat.selectedIndexes[0];
            this._selectedIndexes = stat.selectedIndexes;
            this._value = stat.values[0];
            this._values = stat.values;
        }
        if (!this._multiple &&
            !this.combobox &&
            stat.selectedIndexes.length === 0) {
            this._selectedIndex = -1;
        }
        this.requestUpdate();
    }
    _onComboboxInputFocus(ev) {
        ev.target.select();
    }
    _onComboboxInputInput(ev) {
        this._filterPattern = ev.target.value;
        this._activeIndex = -1;
        this._toggleDropdown(true);
    }
    _onComboboxInputClick() {
        this._toggleDropdown(true);
    }
    _renderOptions() {
        return [];
    }
    _renderDescription() {
        if (!this._options[this._activeIndex]) {
            return nothing;
        }
        const { description } = this._options[this._activeIndex];
        return description
            ? html `<div class="description">${description}</div>`
            : nothing;
    }
    _renderSelectFace() {
        return html `${nothing}`;
    }
    _renderComboboxFace() {
        return html `${nothing}`;
    }
    _renderDropdownControls() {
        return html `${nothing}`;
    }
    _renderDropdown() {
        const classes = classMap({
            dropdown: true,
            multiple: this._multiple,
        });
        return html `
      <div class="${classes}">
        ${this.position === 'above' ? this._renderDescription() : nothing}
        ${this._renderOptions()} ${this._renderDropdownControls()}
        ${this.position === 'below' ? this._renderDescription() : nothing}
      </div>
    `;
    }
    render() {
        return html `
      <slot class="main-slot" @slotchange="${this._onSlotChange}"></slot>
      ${this.combobox ? this._renderComboboxFace() : this._renderSelectFace()}
      ${this._showDropdown ? this._renderDropdown() : nothing}
    `;
    }
}
__decorate([
    property({ type: String, reflect: true, attribute: 'aria-expanded' })
], VscodeSelectBase.prototype, "ariaExpanded", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeSelectBase.prototype, "combobox", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeSelectBase.prototype, "disabled", null);
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeSelectBase.prototype, "invalid", void 0);
__decorate([
    property()
], VscodeSelectBase.prototype, "filter", null);
__decorate([
    property({ type: Boolean, reflect: true })
], VscodeSelectBase.prototype, "focused", void 0);
__decorate([
    property({ type: Array })
], VscodeSelectBase.prototype, "options", null);
__decorate([
    property({ reflect: true })
], VscodeSelectBase.prototype, "position", void 0);
__decorate([
    property({ type: Number, attribute: true, reflect: true })
], VscodeSelectBase.prototype, "tabIndex", void 0);
__decorate([
    queryAssignedElements({
        flatten: true,
        selector: 'vscode-option',
    })
], VscodeSelectBase.prototype, "_assignedOptions", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_activeIndex", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_currentDescription", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_filter", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_filteredOptions", null);
__decorate([
    state()
], VscodeSelectBase.prototype, "_filterPattern", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_selectedIndex", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_selectedIndexes", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_showDropdown", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_options", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_value", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_values", void 0);
__decorate([
    state()
], VscodeSelectBase.prototype, "_listScrollTop", void 0);
__decorate([
    query('.options')
], VscodeSelectBase.prototype, "_listElement", void 0);
//# sourceMappingURL=vscode-select-base.js.map